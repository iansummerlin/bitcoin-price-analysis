# Backtesting Plan for Bitcoin Trading Strategy

This document outlines a robust backtesting strategy for the `trade.py` script, leveraging historical data from `gen.py` and the feature engineering logic from `collect.py`. The goal is to rigorously evaluate the profitability and robustness of the trading strategy under various market conditions.

## 1. Objective

To simulate the performance of the proposed trading strategy (as outlined in `TRADE-IMPROVEMENTS.md`) using historical Bitcoin price data and associated features. The backtest will provide key performance metrics to assess the strategy's viability, identify optimal parameters, and compare different strategy variations.

## 2. Data Sources

*   **Primary Historical Data:** The `BTCUSD_1H.csv` file, which is downloaded and processed by `gen.py`. This file contains historical hourly open, high, low, close, and volume data for BTC/USD.
*   **Feature Data:** The features generated by `collect.py` (and `gen.py` during its data preparation phase) will be crucial. This includes:
    *   Lagged close prices (`close_lag_90`, `close_lag_120`)
    *   Moving Averages (`MA_7`, `MA_24`)
    *   RSI (`rsi`)
    *   Volatility measures (`volatility_24`, `volatility_ewma_24`, `parkinson_volatility`)
    *   Average True Range (`atr_24`)
    *   Fear and Greed Index (`fng_value`)

    The backtesting framework will need to re-calculate these features on the historical data in a similar manner to `collect.py` to ensure consistency.

## 3. Backtesting Framework Design

We will implement a vectorized backtesting approach for initial simplicity, with considerations for an event-driven system for future complexity.

*   **Core Logic Adaptation:**
    *   The `main` function in `trade.py` will be refactored into a reusable function (e.g., `run_strategy`) that accepts historical data as input instead of continuously fetching live data.
    *   The `predict_next_price` function will be used as is, but applied iteratively over the historical dataset.
    *   `execute_buy` and `execute_sell` placeholders will be replaced with internal portfolio management logic that tracks capital, BTC holdings, and trade history.
*   **Data Preparation for Backtest:**
    *   Load the `BTCUSD_1H.csv` and `BTC_sentiment.csv` (from `gen.py`).
    *   Apply the same feature engineering steps as in `gen.py` and `collect.py` to the entire historical dataset to ensure all required exogenous variables are available.
    *   Ensure proper handling of `NaN` values introduced by feature calculations (e.g., dropping initial rows).
*   **Simulation Loop:** Iterate through the historical data row by row (or candle by candle), applying the trading strategy logic at each step.

## 4. Key Performance Indicators (KPIs)

The following metrics will be calculated and reported for each backtest run:

*   **Total Return:** Percentage gain or loss over the backtesting period.
*   **Annualized Return:** Average annual return.
*   **Maximum Drawdown:** The largest peak-to-trough decline in portfolio value.
*   **Sharpe Ratio:** Risk-adjusted return (excess return per unit of total risk).
*   **Sortino Ratio:** Risk-adjusted return (excess return per unit of downside risk).
*   **Win Rate:** Percentage of profitable trades.
*   **Average Win/Loss:** Average profit/loss per winning/losing trade.
*   **Number of Trades:** Total count of buy and sell orders executed.
*   **Profit Factor:** Gross profit divided by gross loss.
*   **Calmar Ratio:** Annualized return divided by maximum drawdown.

## 5. Simulation Details

*   **Initial Capital:** A configurable starting capital (e.g., $10,000 USD).
*   **Transaction Costs:** Implement realistic transaction fees (e.g., 0.1% per trade) and potentially slippage (e.g., a small percentage deviation from the execution price).
*   **Position Sizing:** Start with fixed position sizing (e.g., always trade $100 USD worth of BTC or 0.001 BTC), but design for future dynamic sizing based on risk management principles.
*   **Order Types:** Assume market orders for simplicity in the initial backtest.
*   **Timeframe:** Backtest over the entire available historical dataset from `gen.py`.

## 6. Optimization Strategy

To find the most profitable and robust parameters for the trading strategy:

*   **Parameter Grid Search:** Define a range of values for key strategy parameters (e.g., `BUY_THRESHOLD`, `SELL_THRESHOLD`, stop-loss/take-profit percentages, lookback periods for indicators, RSI overbought/oversold levels).
*   **Iterative Backtesting:** Run the backtest for every combination of parameters in the grid.
*   **Performance Ranking:** Rank parameter combinations based on chosen KPIs (e.g., highest Sharpe Ratio, lowest Max Drawdown).
*   **Walk-Forward Optimization (Future):** For more advanced optimization, consider walk-forward analysis to simulate real-world parameter tuning, where parameters are optimized on an in-sample period and tested on an out-of-sample period, then the window slides forward.

## 7. Reporting and Visualization

*   **Summary Table:** A clear table summarizing the KPIs for each backtest run or optimized parameter set.
*   **Equity Curve:** A plot showing the cumulative portfolio value over time.
*   **Drawdown Plot:** A plot illustrating periods of drawdown.
*   **Trade Log:** Detailed log of each simulated trade (entry/exit price, date, profit/loss, reason).

## 8. Improvements and Future Considerations

*   **Event-Driven Backtester:** Transition to an event-driven framework for more precise simulation of order execution, partial fills, and complex order types.
*   **Multi-Asset Backtesting:** Extend the framework to test strategies across multiple cryptocurrencies.
*   **Machine Learning for Parameter Optimization:** Use more advanced optimization techniques (e.g., genetic algorithms, Bayesian optimization) to explore the parameter space more efficiently.
*   **Robustness Testing:** Conduct stress tests (e.g., during historical crashes) and Monte Carlo simulations to assess strategy robustness.
*   **Forward Testing/Paper Trading:** After backtesting, implement a paper trading phase to test the strategy in a live, but simulated, environment before real capital deployment.

This plan provides a solid foundation for developing a comprehensive backtesting system, crucial for validating and refining the Bitcoin trading strategy.